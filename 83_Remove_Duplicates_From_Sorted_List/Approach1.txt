//*********** Solution Thinking Idea ************
// 1. Check Base cases. 
// 2. Take a pointer which will point to head of the given List.
// 3. Traverse the list and check if the current node value is equal to next node value.
// 4. If yes, then skip the next node.
// 5. If no, then move the pointer to next node.
// 6. Return the head of the list.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
         if(head == null) return head;
         ListNode ll = head;
         while(ll!= null && ll.next!= null){
            if(ll.val == ll.next.val){
                ll.next = ll.next.next;
            }
            else{
                ll = ll.next;
            }
         }
         return head;
    }
}


// Time Complexity = O(n), Traverse all list, n total size.
// Space Complexity = O(1), Due to listNode space pointer.